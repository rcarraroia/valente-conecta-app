// Integration tests for responsive diagnosis features

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { DiagnosisChat } from '@/pages/DiagnosisChat';

// Mock all the hooks and services
vi.mock('@/hooks/useResponsive', () => ({
  useResponsive: vi.fn(),
  useMobileKeyboard: vi.fn(),
  useTouchGestures: vi.fn(),
}));

vi.mock('@/hooks/useDiagnosisAuth', () => ({
  useDiagnosisAuth: () => ({
    user: { id: 'test-user', email: 'test@example.com' },
    isAuthenticated: true,
    isLoading: false,
  }),
}));

vi.mock('@/hooks/useDiagnosisChat', () => ({
  useDiagnosisChat: () => ({
    messages: [],
    isLoading: false,
    error: null,
    isTyping: false,
    sessionId: 'test-session-123',
    sendMessage: vi.fn(),
    startSession: vi.fn(),
    retryLastMessage: vi.fn(),
    clearError: vi.fn(),
  }),
}));

const mockUseResponsive = vi.mocked(
  await import('@/hooks/useResponsive')
).useResponsive;

const mockUseMobileKeyboard = vi.mocked(
  await import('@/hooks/useResponsive')
).useMobileKeyboard;

const mockUseTouchGestures = vi.mocked(
  await import('@/hooks/useResponsive')
).useTouchGestures;

// Test wrapper component
const TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  });\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <BrowserRouter>\n        {children}\n      </BrowserRouter>\n    </QueryClientProvider>\n  );\n};\n\ndescribe('Responsive Diagnosis Integration', () => {\n  beforeEach(() => {\n    // Default desktop setup\n    mockUseResponsive.mockReturnValue({\n      width: 1024,\n      height: 768,\n      isMobile: false,\n      isTablet: false,\n      isDesktop: true,\n      isTouchDevice: false,\n      breakpoint: 'lg',\n      isLandscape: true,\n      isPortrait: false,\n    });\n\n    mockUseMobileKeyboard.mockReturnValue({\n      isKeyboardVisible: false,\n      viewportHeight: 768,\n    });\n\n    mockUseTouchGestures.mockReturnValue({\n      touchState: {\n        isSwipeLeft: false,\n        isSwipeRight: false,\n        isSwipeUp: false,\n        isSwipeDown: false,\n        isPinching: false,\n        scale: 1,\n      },\n      handleTouchGestures: vi.fn(() => vi.fn()),\n    });\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('Desktop Experience', () => {\n    it('should provide full desktop experience', async () => {\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should show full navigation\n      expect(screen.getByText('Dashboard')).toBeInTheDocument();\n      expect(screen.getByText('Pré-Diagnóstico')).toBeInTheDocument();\n      expect(screen.getByText('Início')).toBeInTheDocument();\n\n      // Should show full session info\n      expect(screen.getByText(/Sessão:/)).toBeInTheDocument();\n      expect(screen.getByText(/Status:/)).toBeInTheDocument();\n    });\n\n    it('should handle desktop interactions', async () => {\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should be able to navigate back\n      const backButton = screen.getByText('Dashboard');\n      fireEvent.click(backButton);\n\n      // Should handle home navigation\n      const homeButton = screen.getByText('Início');\n      fireEvent.click(homeButton);\n    });\n  });\n\n  describe('Mobile Experience', () => {\n    beforeEach(() => {\n      mockUseResponsive.mockReturnValue({\n        width: 375,\n        height: 667,\n        isMobile: true,\n        isTablet: false,\n        isDesktop: false,\n        isTouchDevice: true,\n        breakpoint: 'sm',\n        isLandscape: false,\n        isPortrait: true,\n      });\n    });\n\n    it('should provide optimized mobile experience', async () => {\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should show mobile-optimized navigation\n      expect(screen.queryByText('Dashboard')).not.toBeInTheDocument(); // Text hidden on mobile\n      expect(screen.getByText('Diagnóstico')).toBeInTheDocument(); // Shorter title\n      expect(screen.queryByText('Início')).not.toBeInTheDocument(); // Text hidden on mobile\n\n      // Should show condensed session info\n      expect(screen.getByText(/ID:/)).toBeInTheDocument(); // Shorter label\n    });\n\n    it('should handle mobile keyboard interactions', async () => {\n      mockUseMobileKeyboard.mockReturnValue({\n        isKeyboardVisible: true,\n        viewportHeight: 400,\n      });\n\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should hide session footer when keyboard is visible\n      expect(screen.queryByText(/ID:/)).not.toBeInTheDocument();\n    });\n\n    it('should handle touch gestures', async () => {\n      const mockHandleTouchGestures = vi.fn(() => vi.fn());\n      mockUseTouchGestures.mockReturnValue({\n        touchState: {\n          isSwipeLeft: false,\n          isSwipeRight: false,\n          isSwipeUp: false,\n          isSwipeDown: false,\n          isPinching: false,\n          scale: 1,\n        },\n        handleTouchGestures: mockHandleTouchGestures,\n      });\n\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      expect(mockHandleTouchGestures).toHaveBeenCalled();\n    });\n  });\n\n  describe('Tablet Experience', () => {\n    beforeEach(() => {\n      mockUseResponsive.mockReturnValue({\n        width: 768,\n        height: 1024,\n        isMobile: false,\n        isTablet: true,\n        isDesktop: false,\n        isTouchDevice: true,\n        breakpoint: 'md',\n        isLandscape: false,\n        isPortrait: true,\n      });\n    });\n\n    it('should provide balanced tablet experience', async () => {\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should show full navigation like desktop\n      expect(screen.getByText('Dashboard')).toBeInTheDocument();\n      expect(screen.getByText('Pré-Diagnóstico')).toBeInTheDocument();\n      expect(screen.getByText('Início')).toBeInTheDocument();\n\n      // Should show full session info\n      expect(screen.getByText(/Sessão:/)).toBeInTheDocument();\n    });\n  });\n\n  describe('Responsive Breakpoints', () => {\n    const breakpointTests = [\n      {\n        name: 'Extra Small (xs)',\n        width: 320,\n        height: 568,\n        expected: { isMobile: true, isTablet: false, isDesktop: false },\n      },\n      {\n        name: 'Small (sm)',\n        width: 640,\n        height: 1136,\n        expected: { isMobile: true, isTablet: false, isDesktop: false },\n      },\n      {\n        name: 'Medium (md)',\n        width: 768,\n        height: 1024,\n        expected: { isMobile: false, isTablet: true, isDesktop: false },\n      },\n      {\n        name: 'Large (lg)',\n        width: 1024,\n        height: 768,\n        expected: { isMobile: false, isTablet: false, isDesktop: true },\n      },\n      {\n        name: 'Extra Large (xl)',\n        width: 1280,\n        height: 800,\n        expected: { isMobile: false, isTablet: false, isDesktop: true },\n      },\n    ];\n\n    breakpointTests.forEach(({ name, width, height, expected }) => {\n      it(`should handle ${name} breakpoint correctly`, async () => {\n        mockUseResponsive.mockReturnValue({\n          width,\n          height,\n          isMobile: expected.isMobile,\n          isTablet: expected.isTablet,\n          isDesktop: expected.isDesktop,\n          isTouchDevice: expected.isMobile || expected.isTablet,\n          breakpoint: width < 640 ? 'xs' : width < 768 ? 'sm' : width < 1024 ? 'md' : width < 1280 ? 'lg' : 'xl',\n          isLandscape: width > height,\n          isPortrait: height > width,\n        });\n\n        render(\n          <TestWrapper>\n            <DiagnosisChat />\n          </TestWrapper>\n        );\n\n        // Verify appropriate layout is rendered\n        if (expected.isMobile) {\n          expect(screen.getByText('Diagnóstico')).toBeInTheDocument();\n        } else {\n          expect(screen.getByText('Pré-Diagnóstico')).toBeInTheDocument();\n        }\n      });\n    });\n  });\n\n  describe('Orientation Changes', () => {\n    it('should handle portrait to landscape transition', async () => {\n      // Start in portrait\n      mockUseResponsive.mockReturnValue({\n        width: 375,\n        height: 667,\n        isMobile: true,\n        isTablet: false,\n        isDesktop: false,\n        isTouchDevice: true,\n        breakpoint: 'sm',\n        isLandscape: false,\n        isPortrait: true,\n      });\n\n      const { rerender } = render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      expect(screen.getByText('Diagnóstico')).toBeInTheDocument();\n\n      // Switch to landscape\n      mockUseResponsive.mockReturnValue({\n        width: 667,\n        height: 375,\n        isMobile: true,\n        isTablet: false,\n        isDesktop: false,\n        isTouchDevice: true,\n        breakpoint: 'sm',\n        isLandscape: true,\n        isPortrait: false,\n      });\n\n      rerender(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should still show mobile layout but adapted for landscape\n      expect(screen.getByText('Diagnóstico')).toBeInTheDocument();\n    });\n  });\n\n  describe('Performance Considerations', () => {\n    it('should not cause excessive re-renders on resize', async () => {\n      const renderSpy = vi.fn();\n      \n      const TestComponent = () => {\n        renderSpy();\n        return <DiagnosisChat />;\n      };\n\n      render(\n        <TestWrapper>\n          <TestComponent />\n        </TestWrapper>\n      );\n\n      const initialRenderCount = renderSpy.mock.calls.length;\n\n      // Simulate multiple resize events\n      for (let i = 0; i < 5; i++) {\n        mockUseResponsive.mockReturnValue({\n          width: 1024 + i,\n          height: 768,\n          isMobile: false,\n          isTablet: false,\n          isDesktop: true,\n          isTouchDevice: false,\n          breakpoint: 'lg',\n          isLandscape: true,\n          isPortrait: false,\n        });\n      }\n\n      // Should not cause excessive re-renders\n      expect(renderSpy.mock.calls.length).toBeLessThan(initialRenderCount + 10);\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should maintain accessibility on mobile', async () => {\n      mockUseResponsive.mockReturnValue({\n        width: 375,\n        height: 667,\n        isMobile: true,\n        isTablet: false,\n        isDesktop: false,\n        isTouchDevice: true,\n        breakpoint: 'sm',\n        isLandscape: false,\n        isPortrait: true,\n      });\n\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Should have proper ARIA labels\n      const backButton = screen.getByLabelText(/voltar/i) || screen.getByRole('button', { name: /dashboard/i });\n      expect(backButton).toBeInTheDocument();\n\n      const homeButton = screen.getByLabelText(/início/i) || screen.getByRole('button', { name: /home/i });\n      expect(homeButton).toBeInTheDocument();\n    });\n\n    it('should have proper touch targets on mobile', async () => {\n      mockUseResponsive.mockReturnValue({\n        width: 375,\n        height: 667,\n        isMobile: true,\n        isTablet: false,\n        isDesktop: false,\n        isTouchDevice: true,\n        breakpoint: 'sm',\n        isLandscape: false,\n        isPortrait: true,\n      });\n\n      render(\n        <TestWrapper>\n          <DiagnosisChat />\n        </TestWrapper>\n      );\n\n      // Buttons should have minimum touch target size (44px)\n      const buttons = screen.getAllByRole('button');\n      buttons.forEach(button => {\n        const styles = window.getComputedStyle(button);\n        const minSize = parseInt(styles.minHeight) || parseInt(styles.height);\n        expect(minSize).toBeGreaterThanOrEqual(44);\n      });\n    });\n  });\n});